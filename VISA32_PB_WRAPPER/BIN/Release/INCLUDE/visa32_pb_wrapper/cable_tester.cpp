//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : VISA32_PB_WRAPPER_CLASS
//  @ File Name : cable_tester.cpp
//  @ Date : 2013/6/26
//  @ Author : cv
//
//
#define	setbit(x,y) x|=(1<<y) 	//将X的第Y位置1
#define	clrbit(x,y) x&=~(1<<y)	//将X的第Y位清0
#define	getbit(x,y) x&(1<<y)	//将x的第Y位读出

#include	<sstream>		//增加std中string流的支持
#include	<iostream>

#include "cable_tester.h"
#include "visa/visa.h"
#include "VISA32_PB_WRAPPER_DLL.h"

cable_tester::cable_tester()	:	rxd_buffer(NULL), txd_buffer(NULL)
{
	rxd_buffer	=	new unsigned	char[1024*10]();
	txd_buffer	=	new unsigned	char[1024]();

	strcpy((char*)rxd_buffer, "aaaaaaaaaaaaaaa");
	strcpy((char*)txd_buffer, "bbbbbbbbbbbbbbb");
}

cable_tester::~cable_tester()
{
	delete	[]	rxd_buffer;
	delete	[]	txd_buffer;
}

void	cable_tester::clear_rxd_buffer()
{
	for (size_t i=0; i<6000; i++)
	{
		rxd_buffer[i]	=	0x00;
	}
	for (size_t	j=0; j<200; j++)
	{
		connecter[j]	=	false;
	}
}

bool	cable_tester::init()
{
	if (visa32_device::init())
	{
		viSetAttribute(get_device_res(), VI_ATTR_ASRL_BAUD, 115200);	//115200
		viSetAttribute(get_device_res(), VI_ATTR_ASRL_DATA_BITS, 8);	//8bit
		viSetAttribute(get_device_res(), VI_ATTR_ASRL_PARITY, VI_ASRL_PAR_ODD);	//奇校验
		viSetAttribute(get_device_res(), VI_ATTR_ASRL_STOP_BITS, VI_ASRL_STOP_ONE);//一位停止位
		viSetAttribute(get_device_res(), VI_ATTR_ASRL_FLOW_CNTRL,  VI_ASRL_FLOW_NONE);//无控制
		viSetAttribute(get_device_res(), VI_ATTR_TMO_VALUE, 10000);		//10s超时
		viSetAttribute(get_device_res(), VI_ATTR_ASRL_END_IN, VI_ASRL_END_NONE);
		viSetAttribute(get_device_res(), VI_ATTR_TERMCHAR_EN, VI_FALSE);	//不使用终止字符
		//viSetAttribute(get_device_res(), VI_ATTR_TERMCHAR_EN, VI_TRUE); //使用终止字符
		//viSetAttribute(get_device_res(), VI_ATTR_TERMCHAR, 0x6F);		//使用0x6F为终止字符
		viSetBuf(get_device_res(), VI_IO_IN_BUF, 0x8000);
		return	true;
	} 
	else
	{
		return	false;
	}
}

bool	cable_tester::connect_test()	const
{
	bool	result	=	true;
	txd_buffer[0]	=	0xEB;
	txd_buffer[1]	=	0x90;
	txd_buffer[2]	=	0xA1;
	txd_buffer[3]	=	0x00;
	txd_buffer[4]	=	0x14;
	txd_buffer[5]	=	0x6F;
	DWORD	txd_count_final	=	0;
	DWORD	rxd_count_final	=	0;

	viWrite(get_device_res(), txd_buffer, 6, &txd_count_final);
	viRead(get_device_res(), rxd_buffer, 6, &rxd_count_final);
	VISA32_PB_WRAPPER_DLL::beeper_wrapper2(100);

	if (6	==	rxd_count_final)
	{
	}
	else
	{
		return	false;
	}

	for (size_t i=0; i<6; i++)
	{
		if (txd_buffer[i]	!=	rxd_buffer[i])
		{
			result	=	false;
			break;
		}
	}	
	return	result;
}

bool	cable_tester::single_test(const	unsigned	char	param1)
{
	txd_buffer[0]	=	0xEB;
	txd_buffer[1]	=	0x90;
	txd_buffer[2]	=	0xA3;
	txd_buffer[3]	=	param1;
	txd_buffer[4]	=	0x14;
	txd_buffer[5]	=	0x6F;
	unsigned	int	counter	=	0;
	DWORD	txd_count_final	=	0;
	DWORD	rxd_count_final	=	0;

	viWrite(get_device_res(), txd_buffer, 6, &txd_count_final);
	viRead(get_device_res(), rxd_buffer, 1024*10, &rxd_count_final);

	for (size_t	j=2; j<27; j++)
	{
		for (size_t	i=0; i<8; i++, counter++)
		{
			if (getbit(rxd_buffer[j], i))
			{
				connecter[counter]	=	true;
			}
			else
			{
				connecter[counter]	=	false;
			}			
		}	
	}
	single_test_result(param1);
	return	true;
}

bool	cable_tester::continue_test()
{
	txd_buffer[0]	=	0xEB;
	txd_buffer[1]	=	0x90;
	txd_buffer[2]	=	0xA2;
	txd_buffer[3]	=	0x00;
	txd_buffer[4]	=	0x14;
	txd_buffer[5]	=	0x6F;
	unsigned	int	counter	=	0;
	size_t	k	=	0;

	connect_gnd.X	= 96;
	connect_gnd.Y	= 0;
	no_connect.X	= 64;
	no_connect.Y	= 0;
	two_connect_one.X	= 0;
	two_connect_one.Y	= 0;
	two_more_connect.X	= 32;
	two_more_connect.Y	= 0;
	error_connect.X	= 128;
	error_connect.Y	= 0;

	DWORD	txd_count_final	=	0;
	DWORD	rxd_count_final	=	0;
	DWORD	rxd_count	=	0;
	
	viWrite(get_device_res(), txd_buffer, 6, &txd_count_final);
	viGetAttribute(get_device_res(), VI_ATTR_ASRL_AVAIL_NUM, &rxd_count);
	while(5004	!=	rxd_count)
	{
		Sleep(200);
		viGetAttribute(get_device_res(), VI_ATTR_ASRL_AVAIL_NUM, &rxd_count);	
	}
	viRead(get_device_res(), rxd_buffer, 5004, &rxd_count_final);
	VISA32_PB_WRAPPER_DLL::beeper_wrapper1(300);

	if (5004	==	rxd_count_final)
	{
		//
	}
	else
	{
		return	false;
	}

	for (k=0; k<100; k++)
	{
		for (size_t	j=2 + k*25; j<27 + k*25; j++)
		{
			for (size_t	i=0; i<8; i++, counter++)
			{
				if (getbit(rxd_buffer[j], i))
				{
					connecter[counter]	=	true;
				}
				else
				{
					connecter[counter]	=	false;
				}			
			}	
		}
		counter	=	0;
		single_test_result(k+1);
	}

	return	true;
}

bool	cable_tester::single_test_result(size_t	param1)
{
	HANDLE hOut;
	DWORD	tick_count	=	0;
	bool	result	=	false;
	std::stringstream	ss;
	std::string	banner;
	size_t	i	=	0;

	hOut = ::GetStdHandle(STD_OUTPUT_HANDLE);
	::SetConsoleTextAttribute(hOut,0xA);

	ss<<param1;
	tick_count	=	connecter.count();
	switch (tick_count)
	{
	case 0:
		connect_gnd.Y	+=	1;
		::SetConsoleCursorPosition(hOut, connect_gnd);
		result	=	false;	///与接地点短接
		banner	=	"id " + ss.str() + " is connect to shell!";
		::SetConsoleTextAttribute(hOut,0xD);	//粉色
		std::cout<<banner<<std::endl;
		break;
	case 1:
		result	=	false;	///无连接点，这里不显示了
		if (true	==	connecter[param1 - 1])
		{
// 			no_connect.Y	+=	1;
// 			::SetConsoleCursorPosition(hOut, no_connect);
// 			banner	=	"id " + ss.str() + " is connect to nothing!";
// 			::SetConsoleTextAttribute(hOut,0xF);	//白色
// 			std::cout<<banner<<std::endl;
		}
		else
		{
			error_connect.Y	+=	1;
			::SetConsoleCursorPosition(hOut, error_connect);
			banner	=	"id " + ss.str() + " is error!";	
			::SetConsoleTextAttribute(hOut,0xC);	//红色
			std::cout<<banner<<std::endl;
		}
		break;
	case 2:
		result	=	true;	///两点的情况
		if	(true == connecter[param1 - 1])
		{
			if (true == connecter[param1 + 99])//一对一的连接
			{
				two_connect_one.Y	+=	1;
				::SetConsoleCursorPosition(hOut, two_connect_one);
				banner	=	"id " + ss.str() + " is one to one connection.";	//绿色
				std::cout<<banner<<std::endl;
			}
			else				//非一对一的连接
			{
				two_more_connect.Y	+=	1;
				::SetConsoleCursorPosition(hOut, two_more_connect);
				::SetConsoleTextAttribute(hOut, BACKGROUND_RED|BACKGROUND_GREEN|BACKGROUND_INTENSITY);//
				banner	=	"id " + ss.str() + ": ";
				std::cout<<banner;
				for (i = 0; i<connecter.size(); i++)
				{
					if (true == connecter[i])
					{
						if (i	>	99)
						{
							std::cout<<"#"<<i - 99<<", ";
						}
						else
						{
							std::cout<<i + 1<<", ";
						}
					}
				}	
				std::cout<<std::endl;
			}
		}
		else
		{
			banner	=	"id " + ss.str() + " is error!";	
			::SetConsoleTextAttribute(hOut,0xC);
			std::cout<<banner<<std::endl;
		}
		break;
	default:			
		result	=	true;	///至少三点
		two_more_connect.Y	+=	1;
		::SetConsoleCursorPosition(hOut, two_more_connect);
		::SetConsoleTextAttribute(hOut, 0xB);	//天蓝
		banner	=	"id " + ss.str() + ": ";
		std::cout<<banner;
		for (i = 0; i<connecter.size(); i++)
		{
			if (true == connecter[i])
			{
				if (i	>	99)
				{
					std::cout<<"#"<<i - 99<<", ";
				}
				else
				{
					std::cout<<i + 1<<", ";
				}
			}
		}	
		std::cout<<std::endl;		
		break;
	}
	::SetConsoleTextAttribute(hOut,0xA);
	return	result;
}
