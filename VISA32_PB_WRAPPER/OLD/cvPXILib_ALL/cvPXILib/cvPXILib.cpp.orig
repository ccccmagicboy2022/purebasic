// cvPXILib.cpp : Defines the entry point for the DLL application.
//

#include "stdafx.h"
//----------------------------------------------------------------
#pragma comment(lib,".\\base_dll\\cviVXDWrapper\\cviVXDWrapper.lib")
#pragma comment(lib,".\\base_dll\\PlxApi631\\PlxApi631.lib")
#pragma comment(lib,".\\base_dll\\wdapi1020\\wdapi1020.lib")
#pragma comment(lib,".\\base_dll\\visa32\\visa32.lib")
#pragma comment(lib,".\\base_dll\\pivxi11\\pivxi11.lib")
#pragma	comment(lib, "winmm.lib")//多媒体定时器库
// #pragma comment(lib,".\\base_dll\\labview.lib")
// #pragma comment(lib,".\\base_dll\\labviewv.lib")
//----------------------------------------------------------------
//----------------------------------------------------------------
#include	"import.h"
#include	"Include/Plx.h"
#include	"Include/PlxApi.h"
#include	"Include/PlxInit.h"
#include	"Include/PciRegs.h"
// #include	"Include/extcode.h"		//<labview的头文件
// #include	"Include/hosttype.h"	//<labview的头文件
// #include	"Include/fundtypes.h"	//<labview的头文件
#include	"cvPXILib.h"
#include	<string>
//----------------------------------------------------------------
#define setbit(x,y) x|=(1<<y) 	//将X的第Y位置1
#define clrbit(x,y) x&=~(1<<y)	//将X的第Y位清0
#define getbit(x,y) x&=(1<<y)	//将x的第Y位读出

#define CONFIG_ADDRESS 0xCF8
#define CONFIG_DATA 0xCFC

BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
    switch (ul_reason_for_call)
	{
		case DLL_PROCESS_ATTACH:				//这里需要增加一些内容
			cvirte_status();					
			plxapi_status();
			windriver_status();
		case DLL_THREAD_ATTACH:					//这里需要增加一些内容
		case DLL_THREAD_DETACH:
		case DLL_PROCESS_DETACH:
			break;
    }
    return TRUE;
}

//--------------------------------------------------


int	MapPhysicalMemory_wrapper(unsigned int	p_address, unsigned int	size, void*	v_address, int*	map_handle)
{			
	return	MapPhysicalMemory(p_address, size, v_address, map_handle);
}


int	UnMapPhysicalMemory_wrapper(int	map_handle)
{
	return	UnMapPhysicalMemory(map_handle);
}


bool	find_resource(unsigned	int	card_find, card_res*	res)
{
	PLX_STATUS	rc;
	PLX_DEVICE_KEY	DeviceKey;
	PLX_DEVICE_OBJECT	Device;
	PLX_PHYSICAL_MEM	BufferInfo;
	bool	result;

	res->bar0	=	PCR_Read(card_find, CFG_BAR0);	//>读bar0首地址
	res->bar2	=	PCR_Read(card_find, CFG_BAR2);	//>读bar2首地址
	res->bar3	=	PCR_Read(card_find, CFG_BAR3);	//>读bar3首地址

	memset(&DeviceKey, PCI_FIELD_IGNORE, sizeof(PLX_DEVICE_KEY));

	rc =                       
		PlxPci_DeviceOpen(
		&DeviceKey,
		&Device
		);	

	rc =                       
		PlxPci_CommonBufferProperties(
		&Device,
		&BufferInfo
		);

	rc	=	PlxPci_DeviceClose(&Device);

	res->dma_buffer	=	(unsigned int)BufferInfo.PhysicalAddr;
	res->dma_buffer_size	=	BufferInfo.Size;

	if	(res->dma_buffer_size<0x400000)	//buffer大小小于4MByte
	{
		MessageBox( NULL, TEXT("dma_buffer_size is less than 4MByte!\nplease check it!"), TEXT("cvPXILib"), MB_ICONEXCLAMATION);		
		result	=	false;
	}
	else
	{
		result	=	true;
	}

	return result;
}


void	HelloWorldDLL()
{
   MessageBox( NULL, TEXT("Hello World!"), 
			TEXT("In cvPXILib.DLL"), MB_OK);//>测试dll用的
}


bool	cvirte_status()
{
	bool	result;

	if	(CVILowLevelSupportDriverLoaded())
	{
		result	=	true;
	}
	else
	{
		MessageBox( NULL, TEXT("cvi run-time error!\nplease reload it!"), TEXT("cvPXILib"), MB_ICONEXCLAMATION);
		result	=	false;
	}

	return	result;
}


int	bit_clear(unsigned	int	address, char	bit)
{
	unsigned	int	data;
	
	if	(bit	>	31)
		{
			MessageBox( NULL, TEXT("bit must at range 0~31. "), TEXT("cvPXILib"), MB_ICONEXCLAMATION);
			return	0;
		}
	else
		{
			data	=	ReadPhyMem32(address);
			clrbit(data, bit);
			WritePhyMem32(address, data);
			return	1;
		}	
}


int	bit_set(unsigned	int	address, char	bit)
{
	unsigned	int	data;
	
	if	(bit	>	31)
		{
			MessageBox( NULL, TEXT("bit must at range 0~31. "), TEXT("cvPXILib"), MB_ICONEXCLAMATION);	
			return	0;
		}
	else
		{
			data	=	ReadPhyMem32(address);
			setbit(data, bit);
			WritePhyMem32(address, data);
			return	1;
		}
}


void	CardInfo(unsigned	int	card_find, char*	card_identifier, card*	card_ident)
{
	/* bit 31=1        (bit is always set for a PCI access)
	bits30:24=0 (reserved)
	bit 23:16=bus number (0-255)
	bits15:11=device # (0-31)
	bits10:8=function # (0-7)
	bits7:0=register number (0-255) */
	
	unsigned	int	bus;
	unsigned	int	device;
	unsigned	int	function;
	char*	temp;
	
	temp	=	(char *)malloc(sizeof(char) * 100);
	
	bus	=	(card_find&0x00ff0000)/0x10000;
	device	=	(card_find&0x0000f800)/0x800;
	function	=	(card_find&0x700)/0x100;
		
	strcpy(card_identifier, "bus:");
	itoa(bus, temp,   10);
	strcat(temp, " dev:");
	strcat(card_identifier, temp);
	itoa(device, temp,   10);
	strcat(temp, " fun:");
	strcat(card_identifier, temp);
	itoa(function, temp,   10);	
	strcat(card_identifier, temp);
	free(temp);
	
	card_ident->bus	=	bus;
	card_ident->device	=	device;
	card_ident->function	=	function;
}


long	ReadPhyMem32(long	address)
{
	long	data;
	ReadFromPhysicalMemoryEx(address, &data, 4, 4);
	return	data;
}


short	ReadPhyMem16(long	address)
{
	short	data;
	ReadFromPhysicalMemoryEx(address, &data, 2, 2);
	return	data;
}


char	ReadPhyMem8(long	address)
{
	char	data;
	ReadFromPhysicalMemoryEx(address, &data, 1, 1);
	return	data;
}


void	WritePhyMem32(long	address, long	data)
{
	WriteToPhysicalMemoryEx(address, &data, 4, 4);
}


void	WritePhyMem16(long	address, short	data)
{
	WriteToPhysicalMemoryEx(address, &data, 2, 2);
}


void	WritePhyMem8(long	address, char	data)
{
	WriteToPhysicalMemoryEx(address, &data, 1, 1);
}


void	CardInfoEx(card_res*	res, card_detail_info* card_info)
{
	card_info->project		=	(unsigned	int)ReadPhyMem32(res->bar2	+	0x4);
	card_info->card			=	(unsigned	int)ReadPhyMem32(res->bar2	+	0x8);
	card_info->varient		=	(unsigned	int)ReadPhyMem32(res->bar2	+	0xC);
	card_info->chasis_slot	=	(unsigned	int)ReadPhyMem32(res->bar2	+	0x10);
	card_info->designer		=	(unsigned	int)ReadPhyMem32(res->bar2	+	0x14);
	card_info->fpga_version	=	(unsigned	int)ReadPhyMem32(res->bar2	+	0x18);
	card_info->chasis_type	=	(unsigned	int)ReadPhyMem32(res->bar2	+	0x1C);
	card_info->bus_type		=	(unsigned	int)ReadPhyMem32(res->bar2	+	0xC0);
}


char	CVI_inp_wrapper(int	address)
{
	return	CVI_inp(address);
}


short	CVI_inpw_wrapper(int	address)
{
	return	CVI_inpw(address);
}


long	CVI_inpd_wrapper(short	address)
{
	return	CVI_inpd(address);
}


char	CVI_outp_wrapper(int	address, char	data)
{
	return	CVI_outp(address, data);
}


short	CVI_outpw_wrapper(short	address, short	data)
{
	return	CVI_outpw(address, data);
}


long	CVI_outpd_wrapper(short	address, long	data)
{
	return	CVI_outpd(address, data);
}


void	DebugControl(card_res* res, debug*	param)
{
	WritePhyMem32(res->bar3	+	0x7C, param->mso7034b);///fifo1_31用于调试
	WritePhyMem32(res->bar3	+	0x7C, param->chipscope_signal_select);
	WritePhyMem32(res->bar3	+	0x7C, param->chipscope_clk_select);
}


long	PCR_Read(unsigned	int	card_find, char offset)
{
	CVI_outpd(CONFIG_ADDRESS, (card_find	+	offset));
	return	CVI_inpd(CONFIG_DATA);
}


void	PCR_Write(unsigned	int	card_find, char offset, long	data)
{
	PLX_STATUS rc;
	card*	card_inden;
	char*	temp;
	
	card_inden	=	(card*)malloc(sizeof(card));
	temp	=	(char *)malloc(sizeof(char) * 100);
	
	CardInfo(card_find, temp, card_inden);
	
	rc	=PlxPci_PciRegisterWrite_BypassOS( 
                (char)card_inden->bus, 
                (char)card_inden->device, 
                (char)card_inden->function, 
                (short)offset, 
                data 
                );
	free(card_inden);
	free(temp);
}


unsigned	int	ReadEeprom(unsigned	int 	card_find, short	offset)
{
	PCR_Write(card_find, 0x4C, offset<<16);
	while(1)
	{
		if	((PCR_Read(card_find, 0x4C)&0x80000000)	==	0x80000000)
			break;
	}
	return	PCR_Read(card_find, 0x50);
}


void	WriteEeprom(unsigned	int	card_find, short	offset, unsigned	int	data)
{
	long	protect;
	
	protect	=	PCR_Read(card_find, CFG_BAR0)	+	0x0E;
	
	WritePhyMem8(protect, 0x0);//取消eeprom写保护
	Sleep(5);
	
	PCR_Write(card_find, 0x50, data);//载入要写入的数据
	PCR_Write(card_find, 0x4C, (0x80000000	+	(offset<<16)));
	
	// while(1)
	// {
		// if	((PCR_Read(card_find, 0x4C)&0x80000000)	==	0x0)
			// break;
	// }
	
	Sleep(5);
	WritePhyMem8(protect, 0x30);//eeprom写保护，恢复默认的保护
}


void	ResetCard(unsigned	int	card_find)
{
	unsigned	int	bar0;
	char*	card_identifier;
	card*	card_ident;

	card_ident	=	(card*)malloc(sizeof(card));
	card_identifier	=	(char *)malloc(sizeof(char) * 100);	
	
	CardInfo(card_find, card_identifier, card_ident);
	
	bar0	=	PCR_Read(card_find, CFG_BAR0);
	bit_set(bar0	+	0x6C, 30);
	Sleep(10);
	bit_clear(bar0	+	0x6C, 30);
	Sleep(10);
	bit_set(bar0	+	0x6C, 29);
	Sleep(10);
	bit_clear(bar0	+	0x6C, 29);
	Sleep(10);
	strcat(card_identifier, "\nCARD RESET OK!");
	MessageBox( NULL, TEXT(card_identifier), TEXT("cvPXILib"), MB_ICONINFORMATION);
	free(card_ident);
	free(card_identifier);
}


bool	IsPlx9054(unsigned	int	card_find)
{	
	unsigned	int	bar0;
	bool	result;
	
	bar0	=	PCR_Read(card_find, CFG_BAR0);
	
	if	(ReadPhyMem32(bar0	+	0x70)	==	0x905410B5)
		{
			MessageBox( NULL, TEXT("经查，确实使用了PLX9054桥芯片！"), TEXT("cvPXILib"), MB_ICONINFORMATION);
			result	=	true;
		}		
	else
		{
			MessageBox( NULL, TEXT("没有使用PLX9054芯片！\n或者由于FPGA导致读取PLX9054寄存器出错！"), TEXT("cvPXILib"), MB_ICONEXCLAMATION);
			result	=	false;
		}			

	return	result;
}


bool	IsEepromPresent(unsigned	int	card_find)
{
	unsigned	int	bar0;
	
	bar0	=	PCR_Read(card_find, CFG_BAR0);
	
	return	read_bit(bar0	+	0x6C, 28);
}


bool	read_bit(unsigned	int	address, char	bit)
{	
	long	data;
	bool	result;
	data	=	ReadPhyMem32(address);
	getbit(data, bit);
	if	(data)
		result	=	true;
	else
		result	=	false;
	return	result;
}

bool	plxapi_status()
{
	U8	VerMajor;
	U8	VerMinor;
	U8	VerRev;
	bool	result;
	
	PlxPci_ApiVersion(
	&VerMajor,
	&VerMinor,
	&VerRev
	);
	
	if	((VerMajor	==	6)&&(VerMinor	==	3)&&(VerRev	==	1))
	{
		result	=	true;
	}
	else
	{
		MessageBox( NULL, TEXT("plxapi version error!\n please check it!"), TEXT("cvPXILib.dll"), MB_ICONINFORMATION);
		result	=	false;
	}
	
	return	result;
}











bool	windriver_status()
{
	return	true;
}


void	PhyMemAlloc()
{

}


void	PhyMemFree()
{

}


bool	IsEepromBlank(unsigned	int	card_find)
{
	return	true;
}


void	LoadDefaultEeprom(unsigned	int	card_find)
{

}


void	EraseEeprom(unsigned	int	card_find)
{

}


